Case t = node x t1 t2


    {}                                                             node x t1 t2   { fun r => [ r = node x t1 t2 ] }
    {TS (node x t1 t2) }                                           node x t1 t2   { fun r => TS (node x t1 t2) * [ r = node x t1 t2 ] } (fold de la pré)
    {\s x * TS t1 * TS t2}                                         node x t1 t2   { fun r => TS r * [ r = node x t1 t2 ] } (subst)
2.2 forall t2' {\s x * TS t1' * TS t2' * [t1' = t1] * [t2' = t2] } node x t1' t2' { fun r => TS r * [ r = node x t1 t2 ] }


     { TS t2 }                              id t2    { fun r => TS r * [ r = t2 ] }
2.1  { \s x * TS t1' * TS t2 * [t1' = t1] } id t2    { fun r => \s x * TS t1' * TS r * [t1' = t1] * [ r = t2 ] }



2. forall t1' { \s x * TS t1' * TS t2 * [ t1' = t1 ] } node x t1' (id t2) { fun r => TS r * [ r = node x t1 t2 ] }


   { TS t1 }                id t1         { fun r => TS r * [ r = t1 ] } (frame rule + induction)
1. { \s x * TS t1 * TS t2 } id t1         { fun r => \s x * TS r * TS t2 * [ r = t1 ] }



{ \s x * TS t1 * TS t2 } node x (id t1) (id t2)                                         { fun r => TS t * [ r = node x t1 t2 ] } (reduction du term + unfold de la pré)
{ TS (node x t1 t2)}     match (node x t1 t2) leaf (fun x y z => node x (id y) (id z))  { fun r => TS r * [ r = node x t1 t2 ] } (reduction du term)
{ TS (node x t1 t2)}     id (node x t1 t2)                                              { fun r => TS r * [ r = node x t1 t2 ] } (Specification)
